# Tree

- 그래프 자료구조의 일종.
- 그래프 탐색은 최악과 평균 수행시간이 크게 달라질 수 있으므로 반드시 모든 경우를 따져봐야 함.
- 문제가 주어졌을 때 용어 개념 정의를 분명히 하기

## 트리의 종류

- 노드로 이루어진 자료구조
- (일반적인) 트리는 하나의 root 노드를 갖는다.
- root 노드는 0개 이상의 자식 노드를 갖고 있다. 자식 노드 또한 0개 이상의 자식 노드를 갖고 있다. 이는 반복적으로 정의된다.

```java
// Node 클래스를 간단히 구현한 예
class Node{
    public String name;
    public Node[] children;
}
```

### 이진 트리 binary tree
트리 중에서 각 노드가 **최대** 두 개의 자식을 갖는 트리가 이진트리.
- 모든 트리가 이진트리는 아니다.
- 자식노드가 없는 트리는 '말단'노드

### 이진 탐색 트리 binary search tree
이진탐색트리 : '모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들' 속성이 모든 노드 n에 대해 참인 트리
- 바로 아래 자식 뿐만 아니라 하위에 있는 모든 자식노드도 포함해서 판별
- 모든 노드에 대해 왼쪽 자식들의 값이 현재 노드값보다 작거나 같다.
- 오른쪽 자식들의 값은 현재 노드의 값보다 반드시 커야 한다.

### 균형 트리 (보충 필요)
균형트리의 개념?
레드-브랙 트리, AVL 트리

### 완전 이진 트리 complte binary tree
트리의 모든 높이에서 노드가 꽉 차있는 트리.
마지막 단계는 꽉 차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.(왼쪽 자식은 없는데 오른쪽 자식이 있으면 안됨)

### 전 이진 트리 full biary tree
모든 노드의 자식이 없거나 정확히 두 개 있는 경우. 자식이 하나만 있는 노드가 존재해선 안된다.

### 포화 이진 트리 perfect binary tree
전 이진트리 + 완전 이진 트리
모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수는 최대가 된다.
노드의 개수가 정확히 2^k-1(k=트리의 높이)개가 되어야 함


## 이진 트리 순회

### 중위 순회 in-order traversal
왼쪽 가지-현재노드-오른쪽 가지 순으로 방문
```java
    void inOrderTraversal(TreeNode node){
        if(node!=null){
            inOrderTraversal(node.left); //가장 왼쪽 말단까지 이동
            visit(node); //방문
            inOrderTraversal(node.right);   
        }
        
    }
```


### 전위 순회 pre-order traversal
현재노드 먼저 방문 후 왼쪽-오른쪽 가지 순으로 방문
```java
    void preOrderTraversal(TreeNode node){
        if(node!=null){
            visit(node); //현재 노드 방문
            preOrderTraversal(node.left); //왼쪽 자식으로 이동
            preOrderTraversal(node.right);   
        }
    }
```



### 후위 순회 post-order traversal
왼쪽 가지-오른쪽 가지-현재노드 순으로 방문
```java
    void postOrderTraversal(TreeNode node){
        if(node!=null){
            postOrderTraversal(node.left); //가장 왼쪽 말단까지 이동
            postOrderTraversal(node.right);  
            visit(node); 
        }
    }
```

## 이진 힙
최소힙(min-heaps)
- 트리의 마지막 단계에서 오른 쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진 트리
- 각 노드의 원소가 자식원소보다 작음 -> 루트는 트리 전체에서 가장 작은 원소

(최대 힙(max-heaps)은 원소가 내림차순으로 정렬되어 있다는 점만 다르다.)

### 삽입 insert
- 완전이진트리의 속성에 따라 새로운 원소는 밑바닥 가장 오른쪽 위치부터 삽입한다.
- 삽입된 원소를 부모 노드와 교환해나가며 작은 원소를 위쪽으로 올린다.
- 수행시간 O(logN) (N: 노드 개수)


### 최소 원소 뽑아내기 extract_min
- 최소원소는 언제나 루트이므로 찾아내기는 쉽다.
- 최소원소를 제거하기 위해서는 그 다음으로 작은 원소를 루트 자리로 이동시켜야 한다.
- 가장 마지막에 위치한 원소와 루트를 교환한 후 해당 원소를 자식노드와 교환해나가며 밑으로 보낸다. 
- 자식노드 왼쪽, 오른쪽 중에서 더 작은 원소를 찾아 비교 및 교환해야 한다.
- 수행시간 O(logN) (N: 노드 개수)


## 트라이 trie (접두사 트리 prefix tree) (보충 필요)
- n차 트리의 변종으로, 각 노드에 문자를 저장하는 자료구조.
- 단어의 끝 표현하기: null node라 불리는 '*노드'를 첨가. '*노드'를 구현할 때는 TrieNode를 상속한 TerminatingTrieNode를 별도로 만들거나 부모 노드 안에 boolean flag 속성을 정의해서 표현할 수 있다.
- 트라이에서 각 노드는 1~문자길이+1개(불린플래그로 표현한다면 문자길이까지)까지 자식을 가질 수 있다.
- 접두사를 빠르게 찾아보기 위해 트라이에 모든 언어를 저장해놓는 방식을 이용할 수 있다.
- 길이가 K인 문자열이 주어졌을 때 트라이는 해당문자열이 유효한 접두사인지 O(K) 시간에 확인할 수 있다. 이는 해시테이블을 사용했을 때와 실질적으로 같은 수행시간이다.
- 유효한 단어집합을 이용하는 많은 문제들은 트라이를 통해 최적화할 수 있다. (예를 들어 m, ma, man, many를 순차적으로 살펴볼 때 매번 처음부터 검토할 필요없이 트리의 현재 노드를 참조값으로 넘길 수 있다.)


## 더 알아볼 내용
- 트리 실제로 구현해보기
- 힙 자료구조
- 균형트리, 트라이 보충



