# 시스템 설계 및 규모 확장성

## 문제를 다루는 방법
- 소통하라: 시스템 설계 문제를 출제하는 가장 큰 목적은 여러분의 의사소통 능력을 평가하기 위함이다
- 처음에는 포괄적으로 접근하라: 알고리즘으로 바로 뛰어들지 말고 특정 부분을 과도하게 파고들지 말라.
- 화이트보드를 사용하라
- 면접관이 우려하는 부분을 인정하라
- 가정을 할 때 주의하라: 잘못된 가정은 문제를 완전히 다르게 바꿔버릴 수 있다
- 여러분이 생각하는 가정을 명확히 언급하라
- 필요하다면 어림잡아 보라: 예를 들어 웹 크롤러를 설계한다고 할 때, 모든 URL을 저장하는 데 필요한 공간이 얼마나 되는지 어림잡아 볼 필요가 있다.
- 뛰어들라: 지원자로서 문제를 책임져야 한다. 질문을 하라. 장단점을 열린 마음으로 받아들이라. 계속해서 깊이 파고들라. 계속해서 향상시켜 나가라.

## 시스템 설계: 단계별 접근법 

TinyURL과 같은 시스템을 설계하라고 한다면?

### 1단계: 문제의 범위를 한정하라

내가 만들고자 하는 시스템과 면접관이 원하는 것이 같은지 확실히 할 수 있다는 점에서 중요한 작업

- 개개인이 원하는 대로 축약된 URL을 만들 수 있는가? 아니면 축약된 URL이 항상 자동으로 생성되는가?
- 클릭에 관한 통계 정보를 기록할 필요가 있는가?
- 한 번 설정된 URL은 영원히 없어지지 않는가? 아니면 일정 시간이 지나면 삭제되는가?

주요한 특징이나 사용되는 사례를 나열해보기
- URL을 TinyURL로 축약
- URL 분석 
- TinyURL과 연결된 URL 검색
- 사용자 계정 및 링크 관리

### 2단계: 합리적인 가정을 만들라
예를 들어, 여러분으 시스템이 하루에 100명의 사용자를 처리할 수만 있으면 된다거나, 메모리에 제약이 없다거나 하는 가정은 합당하지 않다. 어떤 가정을 세우려면 '제품에 대한 감'이 있어야 할 수도 있다.

### 3단계: 중요한 부분을 먼저 그리라
자리에서 일어나 화이트보드에 시스템의 주요한 부분과 동작의 흐름을 다이어그램으로 그리라. 현재 단계에서는 규모 확장성 문제를 무시해도 된다. 그냥 단순하고 명백하게 동작한다고 접근해도 괜찮다.

### 4단계: 핵심 문제점을 찾으라
어느 부분이 병목 지점일까? 이 시스템이 풀어야 할 주된 문제는 무엇인가? 

### 5단계: 핵심 문제점을 해결할 수 있도록 다시 설계하라
시스템에 존재하는 어떤 제약사항도 열린 마음으로 받아들일 수 있어야 한다.


## 규모 확장을 위한 알고리즘: 단계별 접근법

### 1단계: 질문하라

### 2단계: 현실적 제약을 무시하라

### 3단계: 현실로 돌아오라
2단계에서 어느 정도 윤곽을 잡은 후에는 현실적인 제약을 고려하여 어떤 문제가 발생할지 생각해보아야 한다.

### 4단계: 문제를 풀어라
상황에 따라 문제점 자체를 완전히 해결할 수도 있고, 그 수준을 완화시키는 데 그칠 수도 있다. 순환적 접근법(iterative approach)이 일반적으로 유용한 접근법이다. (문제를 해결하고 그 과정에서 새롭게 발생한 문제를 해결하기를 반복하는 작업)


## 시스템 설계의 핵심 개념

### 수평적 vs. 수직적 규모 확장수직
- 수직적 규모 확장 (vertical scaling): 특정 노드의 자원의 양을 늘리는 방법. (예: 서버에 메모리를 추가해 서버의 처리능력을 향상시킨다)
- 수평적 규모 확장 (horizontal scaling): 노드의 개수를 늘리는 방법. (예: 서버를 추가해 각 서버의 부하를 줄인다)

### 서버 부하 분산 장치 local balancer
일반적으로 규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공된다. 이렇게 해야 서버 한 대 때문에 전체 시스템이 죽거나 다운되는 상황을 방지할 수 있다.

### 데이터베이스 역정규화 denormalization 와 NoSQL
SQL과 같은 관계형 데이터베이스의 조인 연산은 시스템이 커질수록 굉장히 느려진다. 역정규화는 데이터베이스에 여분의 정보를 추가해서 읽기 연산 속도를 향상시키는 방법을 말하며, 이를 통해 테이블을 조인할 때보다 더 빠르게 작업을 수행할 수 있다. 혹은 규모 확장성에 좋도록 설계된 NoSQL을 이용할 수 있다.
[NoSQL - 위키백과](https://ko.wikipedia.org/wiki/NoSQL)
[NoSQL - AWS DynamoDB 소개](https://aws.amazon.com/ko/nosql/)
[NoSQL - mongoDB 소개](https://www.mongodb.com/nosql-explained)


## 데이터베이스 분할(샤딩)

샤딩 sharding : 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저장되어 있는지 알 수 있는 방식. 

- 수직적 분할 vertical partitioning: 자료의 특성별로 분할하는 방식. 특정 테이블이 크기가 일정 수준 이상으로 커지면 데이터베이스를 다른 방식으로 재분할해야 할 수도 있다는 단점이 있다.
- 키 혹은 해시 기반 분할: 간단하게 구현하면 mod(key,n)의 값을 이용해서 N개의 서버에 분할 저장하면 된다. 이때 서버의 개수가 사실상 고정되어 있어야 한다는 문제점이 있다. 서버를 추가할 때마다 모든 데이터를 재분배하는 작업이 필요하다.
- 디렉터리 기반 분할: 데이터를 찾을 때 사용되는 조회 테이블 lookup table을 유지하는 방법. 조회 테이블이 단일 장애 지점이 될 수 있고, 지속적으로 테이블을 읽는 행위가 전체 성능에 영향을 미칠 수 있다는 심각한 단점이 있다.

### 캐싱 caching
인메모리 캐시(key-value 구조의 캐시. 일반적으로 애플리케이션과 데이터 저장소 사이에걸리는 시간 위치)를 사용하면 결과를 굉장히 빠르게 가져올 수 있다. 애플리케이션이 어떤 자료를 요청하면 캐시를 먼저 확인하고, 캐시가 해당 키값을 갖고 있지 않으면 그때 데이터 저장소를 살펴본다. 

### 비동기식 처리 & 큐
이상적으로는 속도가 느린 연산은 비동기식으로 처리해야 한다. 어떤 경우에는 연산을 미리 해 놓을 수도 있다. 예를 들어 곧 갱신해야 할 웹사이트의 각 부분들이 큐에 있다고 하자. 이 웹사이트가 어떤 포럼이라면 큐에 들어있는 작업 중 하나는 아마도 가장 최근 올라온 글과 코멘트를 보여주는 페이지를 다시 만들어주는 일일 것이다. 이 경우 약간 오래되어 덜 정확한 최근 글 리스트가, 캐시 미스로 인해 웹사이트 로드 속도가 느려지는 것보다는 낫다.

### 네트워크 성능 척도
- 대역폭 bandwidth : 단위 시간에 전송할 수 있는 데이터의 최대치
- 처리량 throughput : 단위 시간에 실제로 전송된 데이터의 양
- 지연속도 latency: 데이터를 전송하는 데 걸리는 시간

### MapReduce
대용량 데이터 분산처리를 위해 구글에서 개발한 프레임워크. 현재는 구글에 국한되지 않고 널리 사용된다. 많은 과정을 병렬로 처리할 수 있게 도와주기 때문에 굉장히 커다란 데이터에 대해서도 규모 확장이 쉬워진다.
[맵리듀스 - 위키백과](https://ko.wikipedia.org/wiki/%EB%A7%B5%EB%A6%AC%EB%93%80%EC%8A%A4)
[Jeffrey Dean and Sanjay Ghemawat. MapReduce: Simplified Data Processing on Large Clusters,2004](https://static.googleusercontent.com/media/research.google.com/ko//archive/mapreduce-osdi04.pdf)

- Map은 데이터를 입력으로 받은 뒤 <key,value>쌍으로 반환한다.
- Reduce는 키와 값을 입력으로 받은 뒤 나름의 처리과정을 거쳐 새로운 키와 값으로 반환한다.
- 전형적인 예제: 단어 빈도수 세기(pseudo)
```java
    void map(String name, String document){
        for each word w in document:
            emit(w, 1)
    }

    void reduce(String word, Iterator partialCounts){
        int sum = 0
        for each count in partialCounts:
            sum += count
        emit(word, sum)    
    }
```
## 시스템 설계 시 고려할 점

- 실패: 시스템의 어느 부분이든 실패 가능성이 존재하므로 부분별 대비책을 준비해야 한다.
- 가용성 및 신뢰성: 가용성은 사용 가능한 시스템의 시간을 백분율로 나타낸 것이고, 신뢰성은 특정 단위시간에 시스템이 사용 가능한 확률을 나타는 것이다
- 읽기 중심 vs. 쓰기 중심: 쓰는 연산이 많다면 큐 사용을 고려할 수 있고, 쓰는 연산이 많다면 캐시를 사용하는 것이 좋을 수도 있다.
- 보안

## '완벽한' 시스템은 없다
사례를 잘 이해하고, 문제의 범위를 설정하고, 합리적인 가정을 세운 뒤, 명확하게 설계한 시스템을 만드는 것이 중요하다. 내가 설계한 시스템의 약점에 대해 열린 마음을 받아들일 수 있는 점 또한 필요하다. 완벽한 것을 기대하지는 말자.
