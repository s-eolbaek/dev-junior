# 비트 조작

- 기본 연산
    - AND (&) 두 개의 비트 모두 1이어야 참(1)
    - OR (|) 두 개의 비트 중 하나만 1이어도 참(1)
    - XOR (^) 두 개의 비트가 서로 달라야 참(1)
    - NOT (~) 부정. 비트 반전(1->0, 0->1) : 단항연산
- 왼쪽 시프트 연산
   10 (2) <<  = 100 (4)
   100 (4) << = 1000 (8) 

   -> 어떤 수를 왼쪽으로 한 번 시프트한 값은 2를 곱한 것과 같다.     


## 비트 조작을 할 때 알아야 할 사실들과 트릭들

(x : 임의의 수, 0s : 모든 비트가 0인 값, 1s : 모든 비트가 x인 값)
- x ^ 0s = x     x & 0s = 0     x | 0s = x
- x ^ 1s = ~x    x & 1s = x     x | 1s = 1s
- x ^ x = 0      x & x = x      x | x = x 

연산들은 비트 단위로 이루어진다. 한 비트에서 일어나는 일이 다른 비트에 어떤 영향도 미치지 않는다.


## 2의 보수와 음수

- [2의 보수 two's complement](https://ko.wikipedia.org/wiki/2%EC%9D%98_%EB%B3%B4%EC%88%98) : 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수. 
- 컴퓨터는 일반적으로 정수를 저장할 때 2의 보수 형태로 저장한다.
    - 음수의 경우 저장할 수의 절댓값에 부호 비트를 1로 세팅한 뒤 2의 보수를 취한 형태로 표현한다.
    - N 비트 숫자에 대한 2의 보수는 2^N-1 에 대한 보수값과 같다. 
    - -K = concat(1, 2^n-1 - K) : 4비트로 표현된 정수 -3을 예로 들면, 비트 4개 중 하나는 부호를, 나머지 세 개는 값을 표현한다. -3에 대한 2의 보수는 2^3 - 3 = 5 가 된다. 5를 2진수로 표현하면 101이며 부호비트 1을 앞머리에 붙이면 -3에 대한 2의 보수값 1101 을 얻을 수 있다.
    - 또는 양수로 표현된 2진수의 부정(NOT)값에 1을 더한 뒤 앞에 부호비트를 붙인다.

    | 양수 | 음수 |
    |:---:|:---:|    
    | 7 : 0 111 | -1 : 1 111 | 
    | 6 : 0 110 | -2 : 1 110 | 
    | 5 : 0 101 | -3 : 1 101 | 
    | 4 : 0 100 | -4 : 1 100 | 
    | 3 : 0 011 | -5 : 1 011 | 
    | 2 : 0 010 | -6 : 1 010 | 
    | 1 : 0 001 | -7 : 1 001 | 
    | 0 : 0 000 |  0 : 0 000 | 



## 산술 우측 시프트 vs. 논리 우측 시프트

- 산술 우측 시프트(>>): 비트를 옆으로 옮기고 최상위 비트에는 기존 부호비트를 넣는다. 결과적으로 대상값을 2로 나눈 결과와 같다. 
- 논리 우측 시프트 (>>>) : 비트를 옆으로 옮긴 다음 최상위 비트에 0을 넣는다. 



## 기본적인 비트 조작: 비트값 확인 및 채워넣기

(num : 비트를 변경할 숫자값, i : 변경 대상 위치. 맨 오른쪽부터 0,1,2,3...)

### 비트값 확인
i번째 자리를 제외한 나머지 자리를 모두 0으로 만든 후 0과 비교해 값을 얻는다.
```java
boolean getBit(int num, int i){
    return ((num & (1 << i)) != 0);
}
```

### 비트값 채워넣기
i번째 비트를 제외한 자리는 모두 0이 되므로 OR연산을 해도 다른 비트에는 영향을 미치지 않는다.
```java
int setBit(int num, int i){
    return num | ( i << i);
}
```

### 비트값 삭제하기
```java
int clearBit(int num, int i){
    int mask = ~(1 << i);
    return num & mask;
}
```
**최상위 비트에서 i번째 비트까지 모두 삭제하기**
시프트를 통해 0001000 형태로 만든 값에서 1을 빼면 i번째 비트 밑은 1로, 위로는 0으로 세팅된다.
```java
int clearBitsMSBthroghI(int num, int i){
    int mask = (1 << i) - 1;
    return num & mask;    
}
```

**i번째 비트부터 0번째 비트까지 모두 삭제하기**
i+1만큼 시프트하면 i번째 비트 위로는 1로 세팅되고 하위 i개 비트는 모두 0이 된다.
```java
int clearBitIthrough0(int num, int i){
    int mask = (-1 << (i+1));
    return num & mask;
}
```

### 비트값 바꾸기
mask를 이용해 바꾸려는 비트를 0으로 만든 후 OR 연산으로 값을 바꾼다.
```java
int updateBit(int num, boolean bitIs1){
    int value = bitIs11 ? 1 : 0;
    int mask = ~(1 << i);
    return (num & mask) | (value << i);
}
```