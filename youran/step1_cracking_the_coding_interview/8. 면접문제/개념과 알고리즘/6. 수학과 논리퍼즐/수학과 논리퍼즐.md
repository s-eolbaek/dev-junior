# 수학과 논리퍼즐

## 소수
모든 자연수는 소수의 곱으로 나타낼 수 있다.

### 가분성 divisibility
어떤 수 x로 y를 나눌 수 있으려면 x를 소수의 곱으로 분할했을 때 나열되는 모든 소수가 y를 소수의 곱으로 분할했을 때 나열되는 모든 소수의 부분집합이어야 한다. 

x = 2^j0 * 3^j1 * 5^j2 * ....
y = 2^k0 * 3^k1 * 5^k2 * ....

-> x/y (mod(x,y)=0) 을 만족하려면 모든 i에 대해 j^i <= k^i를 만족해야 한다

- 최대공약수 표현 : gcd(x,y) = 2^min(j0, k0) * 3^min(j1,k1) * 5^min(j2,k2) * ...
- 최소공배수 표현 : lcm(x,y) = 2^max(j0, k0) * 3^max(j1,k1) * 5^max(j2,k2) * ...

### 소수 판별
- 2부터 n-1까지 나누어보기
- 2부터 n의 제곱근까지 나누어보기 : n의 제곱근을 넘어서는 수는 이미 나누어 본 값이다.
- 소수목록 만들기: 에라토스테네스의 체 - 소수가 아닌 수는 반드시 다른 소수로 나누어진다.

```java

//책에 나온 힌트대로 배열에 홀수만 저장하도록 개선
boolean[] sieveOfEratosthenes(int max){
    boolean[] flags = new boolean[max/2];
    int count = 0;

    init(flags); //0,1 인덱스를 제외한 모든 원소값을 true로 초기화
    int prime = 3; //짝수를 제외시키면 2의 배수는 모두 제거되므로 3부터 시작
    while(prime <= Math.sqrt(max)){
        crossOff(flags, prime);

        prime = getNextPrime(flags, prime);
    }
    return flags;
}

void crossOff(boolean[] flags, int prime){
    // prime보다 작은 수 k에 대한 k*prime은 이전 루프에서 이미 제거되어 있다
    for(int i=prime*prime; i<flags.length; i+=prime){
        if(i%2 != 0) flags[i] = false;
    }
}

//다음 소수 찾기
int getNextPrime(boolean[] flags, int prime){
    int next = prime +1;
    while(next<flags.length && !flags[next]) next++;

    return next;
}

```


## 확률

### A∩B의 확률 
P(A∩B) = P(B|A)P(A) : A이면서 B일 확률은 A인 상태에서 B인 확률 * A인 확률

예를 들어 1부터 10까지의 수 중 하나를 뽑는다고 할 때, 5보다 작거나 같으면서 짝수인 수를 뽑을 확률은
P(x=짝수 ∩ x<=5) = P(x=짝수 ∩ x<=5)P(x<=5) = (2/5)*(1/2) = 1/5

P(A∩B) = P(B|A)P(A) = P(A|B)P(B) 이므로 B에 속하면서 A에도 속할 확률은 다음과 같이 표현할 수도 있다.

P(A|B) = P(B|A)P(A)/P(B)

* [베이즈 정리(Bayes' Theorem)](https://j1w2k3.tistory.com/1009)
* [베이즈 규칙과 다양한 문제들](https://ratsgo.github.io/statistics/2017/07/01/bayes/)

### A∪B의 확률
P(A∪B) = P(A)+P(B) - P(A∩B)

- 독립성 : A와 B가 서로의 발생 요인에 아무런 관계가 없는 독립 사건이라면, A가 B에 아무런 영향을 미치지 않으므로 P(B|A) = P(B), 곧 P(A∩B) = P(A)P(B)

- 상호배타성(mutual exclusivity): A와 B가 상호배타적(한 사건이 일어난 경우 다른 사건은 발생할 수 없는 경우)이면 P(A∩B) = 0, 곧 P(A∪B) = P(A)+P(B)

- 두 사건 중 하나의 확률이 0이라면 두 사건은 독립적이면서 상호 배타적이다. 반대로 두 사건 모두 확률이 0 이상이면 독립적이면서 상호 배타적인 것은 불가능하다.


## 논리퍼즐

### 규칙과 패턴 찾기 
태우는 데 정확히 한 시간이 걸리는 끈 두 개를 이용해 15분을 재는 방법 구하기
1. 태우는 데 x분이 걸리는 끈과 y분이 걸리는 끈이 주어지면 x+y만큼의 시간을 잴 수 있다: 끈 두 개를 차례로 태우면 두 시간을 잴 수 있다.
2. 태우는 데 x분이 걸리는 끈이 주어지면, x/2분을 잴 수 있다 : 이 문제에서 가장 큰 제약은 끈의 밀도가 일정하지 않아 끈의 절반을 태우는 데 반드시 30분이 걸린다는 보장은 없다는 점이다. 하지만 끈의 양쪽 끝에 불을 붙이면 어느 쪽이 먼저 타든 30분 후에 끈이 다 타버릴 것이다.
3. 1번 끈을 태우는 데 x분이 걸리고 2번 끈을 태우는 데 y분이 걸리면, 2번 끈을 태우는 시간은 (y-x)분이나 (y-x/2)분으로 바꿀 수 있다: 1번 끈은 양쪽 끝에 불을 붙이고 2번 끈은 한쪽 끝에만 불을 붙이면, 1번 끈이 다 탔을 때 2번 끈의 남은 부분은 30분동안 태울 수 있는 길이가 된다. -> 남은 2번 끈의 양쪽 끝에 불을 붙이면 15분 후에 전부 타게 된다.




### 최악의 경우를 최소화하기
주로 어떤 행동을 최소화하거나 지정된 횟수 안에 처리해야 하는 문제
- 나인볼 문제 : 아홉 개의 공 중에서 하나만 무게가 좀 더 나갈 때, 저울을 두 번만 사용해서 무거운 공을 찾아내기 
    - 가장 먼저 생각해볼 수 있는 방법은 하나의 공을 제외한 나머지를 반반씩 나누어 보기. 제외한 공이 가장 무거운 공이라면 두 번 안에 가능하지만 최악의 경우에는 세 번은 재어봐야 알 수 있다.
    - 제외시킬 공의 개수를 늘려 '균형'을 맞추면 다른 그룹에 주어지는 부담을 줄일 수 있다. -> 세 개씩 나누기 (공의 개수가 3의 배수라면 규칙화할 수 있다)


    