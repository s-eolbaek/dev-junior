## big O 


알고리즘의 효율성을 나타내는 지표 혹은 언어. 

### 시간복잡도
- 수행시간의 변화 , 즉 시간증가율을 표현
- O(logN), O(NlogN), O(N), O(N^2), O(2^N)...
- 최선,최악,평균: 최선은 거의 고려되지 않는다.  최악과 평균은 동일한 경우가 많지만 따로 언급해야 하는 경우도 있다.(eg. quick sort)

### 공간 복잡도
  ```java
      int sum(int n){
      	if(n <= 0){
      		return 0;
      	}
        return n + sum(n-1);  
      }
```
위와 같은 재귀함수에서는 기존 호출스택을 유지한 상태에서 깊이를 더하며 계속 연산이 이루어지므로 공간복잡도가 O(N)이 된다. 그러나 단순히 함수를 n번 호출한 경우, 혹은 재귀함수라도 호출 스택이 동시에 존재하지 않아도 되는 경우는 O(1)이다. 

### 상수항, 지배적이지 않은 항은 무시하라
  - O(N^2 + N) → O(N^2)
  - O(5*2^N + 1000N^1000) → O(2^N)
  - O(B^2+A) 는 줄일 수 없음.

### 덧셈 vs. 곱셈
  - 만약 알고리즘이 'A일을 모두 끝마친 후 B일을 수행하라'의 형태라면 A+B
  - "A일을 할 떄마다 B일을 수행하라"의 형태라면 A*B

### 상환시간
  - ArrayList (동적 가변크기 배열)는 배열의 용량이 꽉찼을 때 클래스에서 기존보다 크기가 두 배 큰 배열을 만든 후 이전 배열의 모든 원소를 새 배열에 복사한다.
  - 기본적인 원소삽입시의 수행시간은 O(1)이겠지만, 배열을 증가해야할 때는 O(N)의 시간이 걸린다. 이때, 배열 증가시의 수행시간을 매 삽입시마다 분할 상환한다는 개념으로 계산해볼 수 있다.
  - 길이가 2의 승수만큼 커지는 배열에 x개의 원소를 삽입한다면 1, 2, 4, 8, 16 ... x 순으로 배열의 크기가 증가할 것이고, 그때마다 배열 크기만큼의 시간이 소요된다. 2의 승수 x만큼의 원소를 삽입할 때까지의 소요시간을 모두 더해보면 1+ 2+ 4+ ... x/2 + x 이며 이는 대략 2x 와 같다. → x개의 원소 삽입시마다 드는 시간은 O(2) → O(1)

### logN 수행시간
  - 이진탐색의 경우: N개의 정렬된 원소배열 중에서 x를 찾을 때 사용. 원소 x와 배열의 중간값을 비교해서 같으면 그 위치를 반환. x가 중간값보다 작으면 중간을 기준으로 왼쪽을, 중간값보다 크면 오른쪽을 같은 방법으로 탐색. 따라서 한 번 수행할 때마다 탐색해야 할 원소가 절반씩 줄어든다.
  - 로그의 밑은 상수항이므로 고려하지 않아도 된다. 밑이 다른 로그는 상수항만큼만 차이가 나기 때문.  

### 재귀적으로 수행시간 구하기 case
  ```java
      int f(int n){
      	if(n <= 1){
      		return 1;
      	}
      	return f(n-1) + f(n-1);
      }
 ```

  - 한 번 수행할 때마다 이전보다 두 배 더 많이 호출하게 된다.(노드로 그려보자.)
    2^0(1), 2^1, 2^2 .... 2^n (top-down 방향)
  → 다수의 호출로 이루어진 재귀 함수에서 수행시간은 보통 O(분기^깊이)로 표현된다.
  (상수항만으로 이루어진 로그의 밑과 달리 지수는 무시할 수 없음)


